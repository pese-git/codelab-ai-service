# Итерация 3.2: Поддержка нескольких LLM-провайдеров и хранение моделей в БД

## Цель
Гибко маршрутизировать LLM-запросы по провайдеру и модели через центральную БД с моделями, поддержкой CRUD, динамическим добавлением/отключением моделей, с прозрачным кодом и масштабируемостью.

---

### Фаза 1: Архитектура моделей и интерфейсов

1. **Реализовать SQLAlchemy-модель таблицы llm_models**
   - Основные поля:
     - `model_id`: TEXT (уникальный canonical id, например, `openrouter/gpt-4`)
     - `provider`: TEXT (например, `openrouter`)
     - `adapter_class`: TEXT (dotted-path к Python-классу адаптера)
     - `display_name`
     - `context_length`
     - `is_available`
     - другие метаданные (created_at, updated_at…)

2. **Миграция/создание таблицы в СУБД (alembic/ручная миграция)**

3. **(Опционально) Релационность:** завести схему провайдеров и связь с моделями — если понадобится расширяться в будущем.

---

### Фаза 2: Базовые адаптеры

4. **В каждом адаптере реализовать метод @classmethod supported_models**, который возвращает список словарей с описанием моделей.

5. **Хранить adapter_class как dotted-path в БД**
   - Пример: `app.services.llm_adapters.openrouter.OpenRouterAdapter`
   - Это позволяет делать импорт класса динамически через importlib

6. **Вынести в один файл/модуль список поддерживаемых adapter_class (для наполнения БД и валидности)**

---

### Фаза 3: CRUD и инициализация БД

7. **Реализовать скрипт/endpoint для первичного наполнения/синхронизации таблицы моделей**
   - Собирает все поддерживаемые модели из адаптеров, формирует записи и пишет в БД их актуальное состояние.
   - Возможно — актуализация по расписанию (например, Celery task или cron).

8. **(Опционально) Реализовать REST endpoint/админку для управления моделями**
   - Вкл/выкл модель, управление display_name, context_length, кастомными полями.

---

### Фаза 4: Динамическое построение mapping

9. **Реализовать функцию build_model_adapter_map(db)**
   - На входе: сессия SQLAlchemy
   - На выходе: mapping вида `{model_id: adapter_cls}`
   - Для получения класса из строкового adapter_class используйте importlib:

   ```python
   def build_model_adapter_map(db_session):
       models = db_session.query(LLMModelDB).filter_by(is_available=True).all()
       mapping = {}
       for row in models:
           module_path, class_name = row.adapter_class.rsplit('.', 1)
           module = importlib.import_module(module_path)
           adapter_cls = getattr(module, class_name)
           mapping[row.model_id] = adapter_cls
       return mapping
   ```

10. **Интеграция с DI (FastAPI):**
    - В endpoints передавайте `db: Session = Depends(get_db)`
    - Для каждого запроса строится mapping (или, для производительности, используйте кеш с TTL)

---

### Фаза 5: Обновление endpoint’ов

11. **Модифицируйте endpoint `/v1/chat/completions`**
    - На входе — строка model (например, `openrouter/gpt-4`)
    - Через построенный mapping находите adapter_cls
    - Если не найдено — возвращайте OpenAIError (`model_not_found`)
    - Инициализируйте и вызывайте нужный адаптер

12. **Модифицируйте endpoint "список моделей"**
    - Строится запросом к БД, результат форматируется в структуру API (LLMModel)

---

### Фаза 6: Тесты и документация

13. **Покройте все операции unit/integration тестами:**
    - Миграция/инициализация таблицы
    - CRUD моделей из БД
    - Выбор нужного адаптера
    - Ошибки при невалидной/выключенной модели
    - Корректная агрегация моделей разных провайдеров

14. **Документируйте:**
    - Формат поля `model`
    - Добавление новых моделей через БД
    - Как расширять список адаптеров/провайдеров

---

### Фаза 7: Масштабирование и поддержка

15. **Механизм "горячей" переконфигурации**
    - Можно кешировать mapping в памяти и обновлять его периодически или по сигналу

16. **Добавление новых провайдеров:**
    - Новый Python-класс-адаптер, поддержка моделей в .supported_models, запись о моделях через crud/admin в БД

17. **Планы на будущее:**
    - Добавление бизнес-логики на уровне БД (например, квоты, группа доступности, custom-конфиги провайдера)

---

### Бонус: что делать при изменениях

- При изменении списка моделей у провайдера — пересинхронизировать таблицу скриптом или автоматически.
- Для частично отключённых моделей (is_available=False) — возвращать корректную ошибку.
- Для пользователей — сделать понятный вывод (в админке или API) о том, какие модели сейчас реально доступны.

---

#### Архитектура после выполнения плана:

- Все модели и адаптеры централизованы в БД;
- Добавление новой модели — создание записи в SQL, не правка кода;
- Маршрутизация полностью динамическая и “горячая” — не требует deploy;
- Платформа готова к вводу десятков провайдеров и сотен моделей!
